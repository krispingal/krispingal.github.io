<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scalability on kbabuji</title>
    <link>http://localhost:1313/tags/scalability/</link>
    <description>Recent content in Scalability on kbabuji</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 19 Oct 2024 00:00:00 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/scalability/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Refining Load Balancer</title>
      <link>http://localhost:1313/articles/refining-load-balancer/</link>
      <pubDate>Sat, 19 Oct 2024 00:00:00 -0500</pubDate>
      <guid>http://localhost:1313/articles/refining-load-balancer/</guid>
      <description>&lt;p&gt;In the last article, we covered the basics of building a Layer 7 load balancer in Go, touching on routing, SSL termination, and rate limiting. Since then, the focus has been on improving performance, maintainability, and scalability.&lt;/p&gt;&#xA;&lt;p&gt;This article highlights key upgrades like adopting clean architecture, switching to configuration files, and using connection pooling to enhance backend communication. These changes make the system more flexible and set the stage for even more optimizations, including advanced health checkers, which weâ€™ll explore in the next article.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
