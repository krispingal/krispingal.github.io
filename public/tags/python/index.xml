<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on kbabuji</title>
    <link>http://localhost:1313/tags/python/</link>
    <description>Recent content in Python on kbabuji</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Dec 2024 00:00:00 -0600</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Promises in Python</title>
      <link>http://localhost:1313/articles/promises-in-python/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 -0600</pubDate>
      <guid>http://localhost:1313/articles/promises-in-python/</guid>
      <description>&lt;h2 id=&#34;what-are-promises&#34;&gt;&#xA;  What Are Promises?&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#what-are-promises&#34; aria-label=&#34;Link to section - What Are Promises?&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In JavaScript, Promises are objects that represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide a powerful way to manage asynchronous code, enabling developers to write cleaner and more maintainable logic.&lt;/p&gt;&#xA;&lt;p&gt;Promises allow us to associate handlers for both the success and failure of an asynchronous operation. By treating asynchronous code similarly to synchronous code, they reduce the complexity and improve the readability of workflows that would otherwise be riddled with convoluted callbacksâ€”commonly referred to as &amp;ldquo;callback hell.&amp;rdquo;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding Skip lists</title>
      <link>http://localhost:1313/articles/understanding-skiplists/</link>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0500</pubDate>
      <guid>http://localhost:1313/articles/understanding-skiplists/</guid>
      <description>&lt;p&gt;Suppose you have a sorted collection of elements and need to perform add, delete, and search operations efficiently. Skip lists offer an efficient, probabilistic approach to these operations, achieving an average time complexity of \(O(\log{n})\) for search, insertion, and deletion. While other data structures, such as red-black trees and AVL trees, can provide the same \(O(\log{n})\) efficiency guarantees in both the average and worst cases, skip lists have the advantage of being simpler to implement and understand.&lt;/p&gt;&#xA;&lt;p&gt;With basic data structures like sorted arrays, you can search for elements in \(O(\log{n})\) time using binary search. However, insertion and deletion require shifting elements, leading to \(O(n)\) time complexity for these operations. Conversely, linked lists allow efficient \(O(1)\) insertions and deletions once the target location is found, but finding that location requires \(O(n)\) time in the worst case.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-skip-lists-improve-efficiency&#34;&gt;&#xA;  How Skip Lists improve efficiency&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#how-skip-lists-improve-efficiency&#34; aria-label=&#34;Link to section - How Skip Lists improve efficiency&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;So, how do skip lists achieve \(O(\log{n})\) efficiency for all three operations? Skip lists accomplish this by introducing multiple levels, each serving as an &amp;ldquo;express lane&amp;rdquo; that allows you to skip over sections of the list. The highest levels contain fewer nodes, allowing you to make large jumps, while the lowest level contains all nodes, allowing for precise adjustments when needed. This structure enables fast traversal through the express lanes and, when necessary, you can exit to a lower level for finer-grained searching.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
